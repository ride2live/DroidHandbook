
<!-- saved from url=(0078)file:///C:/Users/Nolwe/Downloads/DroidoLearnContent/collections_map/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Новый документ</title><style type="text/css">ol{margin:0;padding:0}.c9{padding-top:23pt;widows:2;orphans:2;direction:ltr;margin-left:8pt;padding-bottom:-15pt;page-break-after:avoid}.c1{padding-top:5pt;widows:2;margin-right:8pt;orphans:2;direction:ltr;margin-left:23pt;padding-bottom:5pt}.c15{padding-top:23pt;widows:2;orphans:2;direction:ltr;margin-left:8pt;page-break-after:avoid}.c6{padding-top:23pt;widows:2;orphans:2;direction:ltr;margin-left:23pt;page-break-after:avoid}.c11{widows:2;orphans:2;height:11pt;direction:ltr}.c17{widows:2;orphans:2;direction:ltr;margin-left:36pt}.c5{widows:2;orphans:2;text-indent:36pt;direction:ltr}.c13{max-width:595.6pt;background-color:#ffffff;padding:28.3pt 9.6pt 28.3pt 6.8pt}.c12{font-size:14pt;font-family:"Arial"}.c14{font-size:12pt;font-weight:bold}.c4{color:#000000;font-family:"Arial"}.c8{font-size:8pt;font-style:italic}.c2{color:#660066;font-weight:bold}.c7{font-family:"Verdana"}.c16{color:#6699cc}.c3{color:#0000ff}.c0{font-size:10pt}.c10{font-style:italic}.title{widows:2;padding-top:0pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:21pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}.subtitle{widows:2;padding-top:0pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-style:italic;font-size:13pt;font-family:"Trebuchet MS";padding-bottom:10pt;page-break-after:avoid}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{widows:2;padding-top:10pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:16pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h2{widows:2;padding-top:10pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:13pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt;page-break-after:avoid}h3{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:12pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt;page-break-after:avoid}h4{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:11pt;text-decoration:underline;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h5{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h6{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}</style></head><body class="c13"><h2 class="c9"><a name="h.ggnyk29z6jhg"></a><span class="c12">Ассоциативные массивы</span></h2><h3 class="c6"><a name="h.civbijuordq5"></a><span class="c4">Понятие ассоциативного массива</span></h3><p class="c1"><span class="c0">Ассоциативный массив — это набор пар элементов. Каждая пара содержит ключ и значение, причем ключи не повторяются. В любой момент можно получить элемент-значение, ассоциированный (находящийся в паре) с заданным ключом. Ассоциативный массив также называют словарем или отображением.</span></p><p class="c1"><span class="c0">В виде ассоциативного массива удобно хранить, например, строку, полученную из базы данных. Ключом будет название столбца, а значением — значение этого столбца для полученной строки.</span></p><p class="c1"><span class="c0">Можно воспринимать ассоциативный массив как разновидность обычного массива, в котором индексы могут быть не только целыми числами, а произвольными объектами.</span></p><h3 class="c6"><a name="h.luea8bgbozor"></a><span class="c4">Интерфейс Map</span></h3><p class="c1"><span class="c0">Интерфейс Map содержит методы для работы с ассоциативным массивом:</span></p><p class="c1"><span class="c0">size() — возвращает количество элементов (пар) в массиве;</span></p><p class="c1"><span class="c0">containsKey(Object key) — проверяет, существует ли в массиве элемент с ключом key;</span></p><p class="c1"><span class="c0">containsValue(Object value) — проверяет, существует ли в массиве элемент со значением value;</span></p><p class="c1"><span class="c0">get(Object key) — возвращает значение, соответствующее ключу key;</span></p><p class="c1"><span class="c0">put(Object key, Object value) — добавляет в массив элемент с ключом key и значением value. Если элемент с таким ключом уже существует в массиве, то его значение просто изменяется;</span></p><p class="c1"><span class="c0">values() — возвращает значения всех элементов массива в виде коллекции (т.е. возвращаемый результат имеет типCollection);</span></p><p class="c1"><span class="c0">remove(Object key) — удаляет элемент с ключом key, возвращая значение этого элемента (если он есть) и </span><span class="c2 c0 c7">null</span><span class="c0">, если такого элемента не было;</span></p><p class="c1"><span class="c8 c3">об элементах ассоциативного массива Map (интерфейс Map.Entry)</span></p><p class="c1"><span class="c0">clear() — очищает массив;</span></p><p class="c1"><span class="c0">isEmpty() — проверяет, не пуст ли массив.</span></p><h3 class="c6"><a name="h.kcrx0it4b7sk"></a><span class="c4">Класс Hashtable</span></h3><p class="c1"><span class="c0">Класс Hashtable — одна из реализаций интерфейса Map. </span><span class="c7 c3 c14">*</span></p><p class="c1"><span class="c3 c8">о внутренней организации и конструировании класса Hashtable</span></p><p class="c1"><span class="c0">Hashtable имеет наследника — класс Properties, который вместо пар произвольных объектов хранит пары строк. Если в конкретной задаче и ключи и значения элементов ассоциативного массива должны иметь тип String (а это бывает довольно часто), удобнее воспользоваться классом Properties — не надо будет делать постоянное приведение типов.</span></p><p class="c1"><span class="c0">В классе Properties определены методы getProperty(String key) и setProperty(String key, String value), работающие аналогично методам get() и put(), но принимающие параметры типа String.</span></p><p class="c1"><span class="c8 c3">об упорядоченных ассоциативных массивах (интерфейс SortedSet)</span></p><h3 class="c6"><a name="h.vpx1858agks7"></a><span class="c4">Пример работы с ассоциативными массивами</span></h3><p class="c1"><span class="c0">Нужно разработать метод findUser(String login, String password), находящий в базе данных зарегистрированных пользователей пользователя с логином login и паролем password и возвращающий объект класса User, созданный на основе информации из этой БД. Метод должен возвращать </span><span class="c2 c7 c0">null</span><span class="c0">, если пользователя с требуемыми логином и паролем не существует.</span></p><p class="c1"><span class="c0">Пусть сведения о зарегистрированных пользователях хранятся в таблице USERS, имеющей следующую структуру:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 244.00px; height: 232.00px;"><img alt="" src="./collections_map_files/image00.gif" style="width: 244.00px; height: 232.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">Пусть уже имеется вспомогательный метод getNextUser(), который возвращает очередную строку этой таблицы, а если строк больше нет, возвращает </span><span class="c2 c7 c0">null</span><span class="c0">. Заголовок этого метода может выглядеть следующим образом:</span></p><p class="c5"><span class="c0">Map getNextUser();</span></p><p class="c1"><span class="c0">Заметьте, возвращаемый результат имеет интерфейсный тип Map, а не какого-то конкретного класса (например,Hashtable). Это профессиональный подход к разработке метода. Конечно, внутри метода происходит работа с объектом конкретного класса (возможно, с тем же Hashtable — ведь метод должен создать возвращаемый объект, а создать объект абстрактного класс или интерфейса нельзя). Но, скрывая детали своей реализации и сообщая остальной программе лишь минимально необходимую информацию (что возвращаемый результат поддерживает интерфейс Map), метод добивается большей гибкости. Впоследствии может быть принято решение заменить Hashtable на HashMap, и при этом все изменения нужно будет произвести только в теле метода getNextUser(), а не во всех местах программы, где он вызывался.</span></p><p class="c1"><span class="c0">Ключами элементов ассоциативного массива, возвращаемого методом getNextUser(), являются строки, совпадающие с названиями столбцов таблицы, а значениями — строки, содержащие значения из соответствующей ячейки таблицы. Предположим, что этот метод к тому же облегчает нам работу: заменяет значение 0 столбца category на строку </span><span class="c7 c3 c0">"user"</span><span class="c0">, а значение 1 на строку </span><span class="c7 c3 c0">"admin"</span><span class="c0">. Дело в том, что в зависимости от категории пользователя (которая в БД закодирована числом), мы должны создать либо объект класса User, либо объект производного от него класса Admin.</span></p><p class="c1"><span class="c0">Наш метод будет выглядеть следующим образом. (Набирать его нет смысла, просто постарайтесь разобраться. И следите за скобками!)</span></p><p class="c17"><span class="c2 c0">private</span><span class="c0">&nbsp;User findUser(String login, string password) {Map userData = getNextUser();</span><span class="c2 c0">while</span><span class="c0">&nbsp;(userData != </span><span class="c2 c0">null</span><span class="c0">) {if (((String)UserData.get(</span><span class="c3 c0">"login"</span><span class="c0">)).equals(login) &amp;&amp;((String)UserData.get(</span><span class="c3 c0">"password"</span><span class="c0">)).equals(password)) {if (((String)UserData.get(</span><span class="c3 c0">"category"</span><span class="c0">)).equals(</span><span class="c3 c0">"user"</span><span class="c0">))</span><span class="c2 c0">return new</span><span class="c0">&nbsp;User((String)UserData.get(</span><span class="c3 c0">"name"</span><span class="c0">));if (((String)UserData.get(</span><span class="c3 c0">"category</span><span class="c0">")).equals(</span><span class="c3 c0">"admin"</span><span class="c0">))</span><span class="c2 c0">return new</span><span class="c0">&nbsp;Admin((String)UserData.get(</span><span class="c0 c3">"name"</span><span class="c0">));}}userData = getNextUser();}</span><span class="c2 c0">return null</span><span class="c0">;}</span></p><p class="c1"><span class="c0">Обратите внимание как каждый раз, обращаясь к ассоциативному массиву userData методом get() и получая значение, ассоциированное с нужным нам ключом, мы приводим его к типу String.</span></p><p class="c1"><span class="c0">Обратите внимание на организацию цикла </span><span class="c2 c7 c0">while:</span><span class="c0">&nbsp;мы вызываем метод getNextUser(), пока он не возвратит нам значение</span><span class="c2 c7 c0">null</span><span class="c0">. Если в процессе обработки очередного набора данных из таблицы мы обнаружим, что логин и пароль совпадают с параметрами метода, мы завершаем работу метода командой </span><span class="c2 c7 c0">return</span><span class="c0">, возвращая требуемый объект. Если же команда</span><span class="c2 c7 c0">return</span><span class="c0">&nbsp;ни разу не вызовется в цикле, это будет означать, что такого пользователя в базе нет и метод должен вернуть</span><span class="c2 c7 c0">null</span><span class="c0">, что он и делает в последней строке.</span></p><h2 class="c15"><a name="h.vwmv4efyx9z"></a><span class="c12">Классы-оболочки</span></h2><p class="c1"><span class="c0">Объектно-ориентированный подход к описанию коллекций дает нам ряд преимуществ. В частности, возможность помещать в коллекции объекты любых классов. Но при этом простые типы данных оказываются обделенными. Мы не можем создать коллекцию целых чисел </span><span class="c2 c7 c0">int</span><span class="c0">&nbsp;или символов </span><span class="c2 c7 c0">char</span><span class="c14 c7 c3">*</span><span class="c0">.</span></p><p class="c1"><span class="c0">Для того, чтобы работать с простыми типами данных как с объектами (и, в частности, применять их в коллекциях), используются так называемые классы-оболочки (wrappers). Класс-оболочка построен по очень простому принципу: он хранит внутри себя поле простого типа и предоставляет несколько операций для доступа к этому полю.</span></p><p class="c1"><span class="c0">В стандартной библиотеке Java определены восемь классов-оболочек — по одному на каждый простой тип. Их названия совпадают с названиями этих типов, но начинаются с заглавной буквы. То есть, это Byte, Short, Long, Float, Double,Char, Boolean. Исключение — класс-оболочка для целых чисел, который называется Integer. Каждый класс имеет простой конструктор, принимающий величину соответствующего типа.</span></p><p class="c5"><span class="c0">Integer i = </span><span class="c2 c0">new</span><span class="c0">&nbsp;Integer(15);Boolean b = </span><span class="c2 c0">new</span><span class="c0">&nbsp;Boolean(</span><span class="c2 c0">false</span><span class="c0">);</span></p><p class="c1"><span class="c0">При необходимости легко можно получить «содержимое» класса с помощью одного из его методов. Автоматического приведения к простому типу не происходит. Так что, если нам надо передать в какой-то метод параметр типа </span><span class="c2 c7 c0">int</span><span class="c0">, а нужное нам число представляет собой объект класса Integer, надо осуществить явное преобразование:</span></p><p class="c5"><span class="c0">String s;</span><span class="c2 c0">сhar</span><span class="c0">&nbsp;ch = s.charAt(i.intValue);</span></p><p class="c1"><span class="c0">Зато легко теперь добавлять объекты простых типов в любую коллекцию. Например:</span></p><p class="c5"><span class="c0">Vector vect = new Vector();vect.add(b);vect.add(</span><span class="c2 c0">new</span><span class="c0">&nbsp;Double(3.14));</span></p><p class="c1"><span class="c0">Класс Vector в последних версиях Java позволяет передавать в метод и примитивные типы данных, автоматически создавая для них оболочку.</span></p><h2 class="c15"><a name="h.axl9xzg47m3q"></a><span class="c12">Работа с датой и временем</span></h2><p class="c1"><span class="c0">Данные типа дата/время приходится обрабатывать довольно часто, поэтому все современные языки программирования предлагают удобный механизм для работы с ними в одной из своих библиотек.</span></p><p class="c1"><span class="c0">В Java для этих целей разработаны классы Date и Calendar, собранные в пакете java.util.</span></p><p class="c1"><span class="c0">Класс Date хранит число миллисекунд, прошедших с 1 января 1970 года (во внутреннем поле, имеющем тип </span><span class="c7 c0 c16">long</span><span class="c0">). Конструктор без параметров этого класса создает объект, содержащий текущее время (по системным часам машины, на которой выполняется программа). Другой конструктор, с параметром типа </span><span class="c2 c7 c0">long</span><span class="c0">, создает объект Date на основе заданного числа.</span></p><p class="c1"><span class="c0">Метод getTime() позволяет получить это число, а метод setTime(long newTime) — изменить.</span></p><p class="c1"><span class="c0">Для отображения даты на экране ее внутреннее представление необходимо перевести в строку, более удобную для восприятия. Для этого обычно используется класс SimpleDateFormat (являющийся наследником абстрактного классаDateFormat), который надо импортировать из пакета java.text. Прежде всего необходимо создать объект этого класса, указав в качестве параметра конструктора строку, определяющую способ форматирования. Например:</span></p><p class="c5"><span class="c0">SimpleDateFormat formatter = </span><span class="c2 c0">new</span><span class="c0">&nbsp;SimpleDateFormat(</span><span class="c3 c0">"dd.MM.yyyy hh:mm"</span><span class="c0">);</span></p><p class="c1"><span class="c0">Теперь следует вызвать метод format() созданного форматирующего объекта, передав ему в качестве параметра тот объект Date, который мы хотим представить в виде строки. Чтобы вывести на экран текущую дату, используем команду:</span></p><p class="c5"><span class="c0">System.out.println(formatter.format(</span><span class="c0 c2">new</span><span class="c0">&nbsp;Date()));</span></p><p class="c1"><span class="c0">В момент написания этих строк программа вывела в консоль</span></p><p class="c5"><span class="c0">23.09.2007 05:51</span></p><p class="c1"><span class="c0">В строке </span><span class="c7 c3 c0">"dd.MM.yyyy hh:mm"</span><span class="c0">&nbsp;dd означает цифры дня, MM — цифры месяца, yyyy — цифры года, hh — часы и mm — минуты. Комбинация MMMM дала бы название месяца (в именительном падеже), а yy — только две последние цифры года. Названные составляющие могут следовать в любом порядке (причем, все они присутствовать не обязаны), а разделители между ними (в примере это точка, пробел и двоеточие) могут быть и другими.</span></p><p class="c1"><span class="c0">Класс Calendar позволяет работать с датой на более высоком уровне, отдельно рассматривая составляющие даты (число, месяц, год и т.д.). Он является абстрактным, поэтому необходимо пользоваться одним из его наследников. Таковым является GregorianCalendar (описывающий грегорианский календарь, по которому мы живем).</span></p><p class="c1"><span class="c0">Создать объект этого класса, содержащий текущую дату/время можно конструктором без параметров. Всего же у классаGregorianCalendar семь конструкторов, наиболее мощный из них принимает шесть параметров:</span></p><p class="c5"><span class="c0">GregorianCalendar(</span><span class="c2 c0">int</span><span class="c0">&nbsp;year, </span><span class="c2 c0">int</span><span class="c0">&nbsp;month, </span><span class="c2 c0">int</span><span class="c0">&nbsp;day, </span><span class="c2 c0">int</span><span class="c0">&nbsp;hour, </span><span class="c2 c0">int</span><span class="c0">&nbsp;minutes, </span><span class="c2 c0">int</span><span class="c0">&nbsp;seconds)</span></p><p class="c1"><span class="c0">Получить любую часть даты можно с помощью универсального метода get(int field). Целочисленный параметр fieldопределяет желаемую часть даты.</span></p><p class="c1"><span class="c0">В классе Calendar определены константы, описывающие возможные варианты: </span><span class="c0 c10">ERA, YEAR, MONTH, WEEK_OF_YEAR, WEEK_OF_MONTH, DAY_OF_YEAR, DAY_OF_MONTH, DAY_OF_WEEK, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND</span><span class="c0">&nbsp;и несколько других.</span></p><p class="c1"><span class="c0">Например, узнаем, какой сегодня день года:</span></p><p class="c5"><span class="c0">GregorianCalendar today = </span><span class="c2 c0">new</span><span class="c0">&nbsp;GregorianCalendar();</span><span class="c2 c0">int</span><span class="c0">&nbsp;result = today.get(Calendar.</span><span class="c0 c10">DAY_OF_YEAR</span><span class="c0">);System.out.println(result);</span></p><p class="c1"><span class="c0">Любую часть даты можно изменить методом set(int field, int value).</span></p><p class="c11"><span></span></p></body></html>