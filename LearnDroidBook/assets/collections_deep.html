
<!-- saved from url=(0079)file:///C:/Users/Nolwe/Downloads/DroidoLearnContent/collections_deep/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Новый документ</title><style type="text/css">ol{margin:0;padding:0}.c17{padding-top:23pt;widows:2;orphans:2;direction:ltr;margin-left:8pt;padding-bottom:-15pt;page-break-after:avoid}.c1{padding-top:5pt;widows:2;margin-right:8pt;orphans:2;direction:ltr;margin-left:23pt;padding-bottom:5pt}.c10{padding-top:23pt;widows:2;orphans:2;direction:ltr;margin-left:23pt;page-break-after:avoid}.c7{widows:2;orphans:2;text-indent:36pt;direction:ltr;margin-left:36pt}.c13{color:#0000ff;font-size:12pt;font-family:"Verdana";font-weight:bold}.c3{widows:2;orphans:2;height:11pt;direction:ltr}.c8{widows:2;orphans:2;text-indent:36pt;direction:ltr}.c6{color:#660066;font-family:"Verdana";font-weight:bold}.c11{max-width:595.6pt;background-color:#ffffff;padding:28.3pt 9.6pt 28.3pt 6.8pt}.c4{color:#000000;font-family:"Arial"}.c9{color:#660066;font-weight:bold}.c14{color:#0000ff;font-size:8pt}.c12{color:#1155cc;text-decoration:underline}.c18{color:inherit;text-decoration:inherit}.c16{font-size:14pt;font-family:"Arial"}.c0{font-size:10pt}.c15{color:#0000ff}.c5{font-style:italic}.c2{color:#6699cc}.title{widows:2;padding-top:0pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:21pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}.subtitle{widows:2;padding-top:0pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-style:italic;font-size:13pt;font-family:"Trebuchet MS";padding-bottom:10pt;page-break-after:avoid}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{widows:2;padding-top:10pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:16pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h2{widows:2;padding-top:10pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:13pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt;page-break-after:avoid}h3{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:12pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt;page-break-after:avoid}h4{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:11pt;text-decoration:underline;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h5{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h6{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}</style></head><body class="c11"><h2 class="c17"><a name="h.8ye0qe18ho93"></a><span class="c16">Классы-коллекции</span></h2><h3 class="c10"><a name="h.ax3aack4j0uj"></a><span class="c4">Понятие коллекции</span></h3><p class="c1"><span class="c0">Для хранения большого количества однотипных данных могут использоваться массивы, но они не всегда являются идеальным решением. Во-первых, длина массива задается заранее и в случае, если количество элементов заранее неизвестно, придется либо выделять память «с запасом», либо предпринимать сложные действия по переопределению массива. Во-вторых, элементы массива имеют жестко заданное размещение в его ячейках, поэтому, например, удаление элемента из массива не является простой операцией.</span></p><p class="c1"><span class="c0">В программировании давно и эффективно используются такие структуры данных как стек, очередь, список, множество и т.д., объединенные общим названием коллекция. Коллекция — это группа элементов с операциями добавления, извлечения и поиска элемента. Механизм работы операций существенно различается в зависимости от типа коллекции. Например, элементы </span><span class="c0 c5">стека</span><span class="c0">&nbsp;упорядочены в последовательность, добавление нового элемента может происходить только в конец этой последовательности, и получить можно только элемент, находящийся в конце (то есть, добавленный последним). </span><span class="c0 c5">Очередь</span><span class="c0">, напротив, позволяет получить лишь первый элемент (элементы добавляются в один конец последовательности, а «забираются» с другого). Другие коллекции (например, </span><span class="c0 c5">список</span><span class="c0">) позволяют получить элемент из любого места последовательности, а </span><span class="c0 c5">множество</span><span class="c0">&nbsp;вообще не упорядочивает элементы и позволяет (помимо добавления и удаления) только узнать, содержится ли в нем данный элемент.</span></p><p class="c1"><span class="c0">Язык Java предоставляет библиотеку стандартных коллекций, которые собраны в пакете java.util, поэтому нет необходимости программировать их самостоятельно.</span></p><p class="c1"><span class="c0">При работе с коллекциями главное избегать ошибки начинающих — пользоваться наиболее универсальной коллекцией вместо той, которая необходима для решения задачи — например, списком вместо стека. Если логика работы программы такова, что данные должны храниться в стеке (появляться и обрабатываться в обратной последовательности), следует использовать именно стек. В этом случае вы не сможете нарушить логику обработки данных, обратившись напрямую к середине последовательности, а значит, шанс появления трудно обнаруживаемых ошибок резко уменьшается.</span></p><p class="c1"><span class="c0">Чтобы выбрать коллекцию, которая лучше всего подходит условию задачи, необходимо знать особенности каждой из них. Эти знания являются обязательными для любого программиста, поскольку без применения тех или иных коллекций редко обходится любая современная задача. Некоторые сведения вы сможете почерпнуть из дальнейшего изложения.</span></p><h3 class="c10"><a name="h.84r57djy0ia4"></a><span class="c4">Классы-коллекции</span></h3><p class="c1"><span class="c0">Коллекции в библиотеке java.util представлены набором классов и интерфейсов.</span></p><p class="c1"><span class="c0">Каждый класс реализует некоторую коллекцию со специфичным для нее набором операций доступа к элементам. Чтобы использовать коллекцию в своей программе, нужно создать объект соответствующего класса.</span></p><p class="c1"><span class="c0">Элементы большинства коллекций имеют тип Object. Это значит, что (в отличие от обычного массива) вы не должны заранее указывать тип элементов, которые будете помещать в коллекцию. Вы можете добавлять в нее объекты любого класса, поскольку все классы являются наследниками класса Object, более того — в одной коллекции могут храниться объекты совершенно разных классов.</span></p><p class="c1"><span class="c0">Конечно, это может привести и к трудностям. Если вы захотите совершать какие-то операции над элементом коллекции (а вы помещаете в коллекцию объекты именно для того, чтобы потом их извлекать и обрабатывать), вы не сможете воспользоваться его методами, не приведя объект к его «настоящему» классу посредством явного приведения типов.</span></p><p class="c1"><span class="c0">Например, у вас есть объект класса String (обычная строка) и вы хотите добавить его в стек stack с помощью методаpush(Object item):</span></p><p class="c8"><span class="c0">String str = </span><span class="c0 c15">"Ценная строка"</span><span class="c0">;stack.push(str);</span></p><p class="c1"><span class="c0">Коллекция, хранящая элементы типа Object, сразу же «забывает», что ваш объект — строка, поскольку при его добавлении было осуществлено автоматическое приведение типа String к типу Object. Вы можете извлечь ваш объект методом pop(), но чтобы вернуть ему прежний тип (а без этого вы не сможете воспользоваться ни одним из его методов), придется осуществить явное преобразование оператором (String):</span></p><p class="c8"><span class="c0">str = (String)stack.pop();</span></p><p class="c1"><span class="c0">Это не является проблемой, просто нужно помнить, объекты какого класса вы помещаете в коллекцию и выполнять соответствующее преобразование типа над каждым побывавшим в коллекции элементом.</span></p><p class="c1"><span class="c0">Но если попытаться привести объект к неправильному типу, возникнет ошибка в программе:</span></p><p class="c7"><span class="c0">stack.push(</span><span class="c9 c0">new</span><span class="c0">&nbsp;Dog(</span><span class="c0 c15">"Шарик"</span><span class="c0">, 12)); </span><span class="c0 c2">// помещаем в стек собаку</span><span class="c0">str = (Mouse)stack.pop(); </span><span class="c0 c2">// вынимаем собаку и пытаемся объявить ее мышью, но эти классы не связаны наследованием и программа выдаст ошибку во время выполнения</span></p><p class="c1"><span class="c0">Так что, возможностью помещать в коллекцию </span><span class="c0 c5">любые</span><span class="c0">&nbsp;объекты, воспользоваться скорее всего не получится. Представьте себе, что ваша программа должна «помнить», что первый элемент списка — строка, второй — число, третий — собака, четвертый — опять число. И обработать их все в цикле она, наверное, не сможет, поскольку у этих объектов нет общих методов. В результате теряются все преимущества использования коллекции. Поэтому в каждую коллекцию следует помещать объекты только одного класса (и производных от него).</span></p><h3 class="c10"><a name="h.4iq8h8i9rhl9"></a><span class="c4">Интерфейсы-коллекции</span></h3><p class="c1"><span class="c0">Некоторые коллекции в пакете java.utils не представлены самостоятельными классами. Например, очередь и список. Но для этих полезных структур данных определены соответствующие интерфейсы, то есть можно пользоваться любым классом, реализующим такой интерфейс.</span></p><p class="c1"><span class="c0">Интерфейс может использоваться в качестве типа данных так же, как и класс. Разница лишь в том, что объекты интерфейсного типа нельзя создать напрямую — необходимо выбрать класс, поддерживающий этот интерфейс и вызвать его конструктор.</span></p><p class="c1"><span class="c0">Пусть, к примеру, нужен список, одна из наиболее удобных и часто употребляемых структур данных. Список — это упорядоченная последовательность элементов, каждый из которых можно получить по его позиции. Кроме того можно добавлять элементы в требуемые позиции списка и удалять их, при этом (и это главное удобство в отличие от массива) остальные элементы автоматически «раздвигаются» или «сдвигаются» так, что непрерывная связность списка сохраняется.</span></p><p class="c1"><span class="c0">Список представлен в пакете java.util интерфейсом List. Вы можете создавать переменные этого типа и объявлять функции с таким параметром. Например, класс Game в программе игры в шашки (см. </span><span class="c0 c12"><a class="c18" href="http://www.google.com/url?q=http%3A%2F%2Fmath.sgu.ru%2Fsites%2Fchairs%2Fprinf%2Fmaterials%2Fjava%2Fmaintask.htm&sa=D&sntz=1&usg=AFQjCNESh5jDFBfW31ITXa-KsBCKqPL8nw">задание 16</a></span><span class="c0">) имеет поле checkersтипа List, хранящее все черные и белые шашки (объекты типа Checker). Когда шашку съедают, ее надо просто удалить из списка с помощью одного из удобных методов, определенных в интерфейсе List:</span></p><p class="c8"><span class="c0">checkers.remove(check); </span><span class="c0 c2">// удаляем из списка checkers съеденную шашку check</span></p><p class="c1"><span class="c0">Когда программе понадобится узнать обо всех оставшихся шашках (например, чтобы нарисовать их на экране), методgetCheckers() класса Game передаст ей список:</span></p><p class="c8"><span class="c0">List ch = currentGame.getCheckers(); </span><span class="c0 c2">// здесь currentGame — объект класса Game</span></p><p class="c1"><span class="c0">Теперь программа может работать с переменной ch как со списком (например, по очереди получить все его объекты).</span></p><p class="c1"><span class="c0">В момент создания новой игры (т.е. в конструкторе класса Game) надо, очевидно, создать 24 шашки, расположенные на стандартных позициях и добавить их в список checkers. Но список тоже необходимо создать, а мы не можем воспользоваться конструкцией</span></p><p class="c8"><span class="c0">checkers = </span><span class="c9 c0">new</span><span class="c0">&nbsp;List();</span></p><p class="c1"><span class="c0">поскольку List не является классом и не имеет конструктора. Нам нужно выбрать любой </span><span class="c0 c5">класс, реализующий интерфейс </span><span class="c0">List и создать объект этого класса. Например, класс Vector</span></p><p class="c8"><span class="c0">checkers = </span><span class="c9 c0">new</span><span class="c0">&nbsp;Vector();</span></p><p class="c1"><span class="c0">или класс ArrayList</span><span class="c13">*</span><span class="c0">:</span></p><p class="c8"><span class="c0">checkers = </span><span class="c0 c9">new</span><span class="c0">&nbsp;ArrayList();</span></p><p class="c1"><span class="c0">Независимо от того, какой именно класс мы выберем, поле checkers будет иметь тип List и на дальнейшую работу с ним наш выбор не повлияет. Мы будем добавлять шашки в список, удалять их из него, возвращать хранящиеся в списке шашки и т.д. посредством методов интерфейса List.</span></p><h3 class="c10"><a name="h.bhz1wxt2tdz4"></a><span class="c4">Интерфейс Collection</span></h3><p class="c1"><span class="c0">Интерфейс Collection содержит набор общих методов, которые используются в большинстве коллекций. Рассмотрим основные из них.</span></p><p class="c1"><span class="c0">add(Object item) — добавляет в коллекцию новый элемент. Метод возвращает </span><span class="c6 c0">true</span><span class="c0">, если добавление прошло удачно и </span><span class="c6 c0">false</span><span class="c0">&nbsp;— если нет</span><span class="c13">*</span><span class="c0">. Если элементы коллекции каким-то образом упорядочены, новый элемент добавляется в конец коллекции.</span></p><p class="c1"><span class="c0">clear() — удаляет все элементы коллекции.</span></p><p class="c1"><span class="c0">contains(Object obj) — возвращает </span><span class="c0 c6">true</span><span class="c0">, если объект obj содержится в коллекции и </span><span class="c6 c0">false</span><span class="c0">, если нет.</span></p><p class="c1"><span class="c0">isEmpty() — проверяет, пуста ли коллекция.</span></p><p class="c1"><span class="c14 c5">о методах интерфейса Collection</span></p><p class="c1"><span class="c0">remove(Object obj) — удаляет из коллекции элемент obj. Возвращает </span><span class="c6 c0">false</span><span class="c0">, если такого элемента в коллекции не нашлось.</span></p><p class="c1"><span class="c0">size() — возвращает количество элементов коллекции.</span></p><h3 class="c10"><a name="h.fpmnl1n758cs"></a><span class="c4">Интерфейс List</span></h3><p class="c1"><span class="c0">Интерфейс List описывает упорядоченный список. Элементы списка пронумерованы, начиная с нуля и к конкретному элементу можно обратиться по целочисленному индексу. Интерфейс List является наследником интерфейсаCollection, поэтому содержит все его методы и добавляет к ним несколько своих:</span></p><p class="c1"><span class="c0">add(int index, Object item) — вставляет элемент item в позицию index, при этом список раздвигается (все элементы, начиная с позиции index, увеличивают свой индекс на 1);</span></p><p class="c1"><span class="c0">get(int index) — возвращает объект, находящийся в позиции index;</span></p><p class="c1"><span class="c0">indexOf(Object obj) — возвращает индекс первого появления элемента obj в списке;</span></p><p class="c1"><span class="c0">lastIndexOf(Object obj) — возвращает индекс последнего появления элемента obj в списке;</span></p><p class="c1"><span class="c0">add(int index, Object item) — заменяет элемент, находящийся в позиции index объектом item;</span></p><p class="c1"><span class="c0">subList(int from, int to) — возвращает новый список, представляющий собой часть данного (начиная с позицииfrom до позиции to-1 включительно).</span></p><h3 class="c10"><a name="h.zfdx26ps5tak"></a><span class="c4">Интерфейс Set</span></h3><p class="c1"><span class="c0">Интерфейс Set описывает множество. Элементы множества не упорядочены, множество не может содержать двух одинаковых элементов. Интерфейс Set унаследован от интерфейса Collection, но никаких новых методов не добавляет. Изменяется только смысл метода add(Object item) — он не станет добавлять объект item, если он уже присутствует во множестве.</span></p><h3 class="c10"><a name="h.asvssdfyc5ht"></a><span class="c4">Интерфейс Queue</span></h3><p class="c1"><span class="c0">Интерфейс Queue описывает очередь. Элементы могут добавляться в очередь только с одного конца, а извлекаться с другого (аналогично очереди в магазине). Интерфейс Queue так же унаследован от интерфейса Collection. Специфические для очереди методы:</span></p><p class="c1"><span class="c0">poll() — возвращает первый элемент и удаляет его из очереди.</span></p><p class="c1"><span class="c5 c14">о методах интерфейса Queue</span></p><p class="c1"><span class="c0">peek() — возвращает первый элемент очереди, не удаляя его.</span></p><p class="c1"><span class="c0">offer(Object obj) — добавляет в конец очереди новый элемент и возвращает </span><span class="c6 c0">true</span><span class="c0">, если вставка удалась.</span></p><h3 class="c10"><a name="h.b4namhm4gqko"></a><span class="c4">Иерархия классов-коллекций</span></h3><p class="c1"><span class="c0">Классы-коллекции, реализующие описанные выше интерфейсы, являются наследниками абстрактного классаAbstractCollection. Иерархия этих классов приведена на рисунке (синим цветом показаны интерфейсы). Мы рассмотрим те из них, которые представляют наибольший практический интерес.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 569.33px; height: 522.67px;"><img alt="" src="./collections_deep_files/image00.gif" style="width: 569.33px; height: 522.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c10"><a name="h.1eo4wuaep0v9"></a><span class="c4">Класс Vector</span></h3><p class="c1"><span class="c0">Vector (вектор) — набор упорядоченных элементов, к каждому из которых можно обратиться по индексу. По сути эта коллекция представляет собой обычный список.</span></p><p class="c1"><span class="c14 c5">об устройстве и конструировании класса Vector</span></p><p class="c1"><span class="c0">Класс Vector реализует интерфейс List, основные методы которого названы выше. К этим методам добавляется еще несколько. Например, метод firstElement() позволяет обратиться к первому элементу вектора, метод lastElement()— к его последнему элементу. Метод removeElementAt(int pos) удаляет элемент в заданной позиции, а методremoveRange(int begin, int end) удаляет несколько подряд идущих элементов. Все эти операции можно было бы осуществить комбинацией базовых методов интерфейса List, так что функциональность принципиально не меняется.</span></p><h3 class="c10"><a name="h.fkalslwhqu70"></a><span class="c4">Класс ArrayList</span></h3><p class="c1"><span class="c0">Класс ArrayList — аналог класса Vector. Он представляет собой список и может использоваться в тех же ситуациях. Основное отличие в том, что он не синхронизирован и одновременная работа нескольких параллельных процессов с объектом этого класса не рекомендуется. В обычных же ситуациях он работает быстрее. </span><span class="c13">*</span></p><h3 class="c10"><a name="h.wnwysljqs6r4"></a><span class="c4">Класс Stack</span></h3><p class="c1"><span class="c0">Stack — коллекция, объединяющая элементы в стек. Стек работает по принципу LIFO (последним пришел — первым ушел). Элементы кладутся в стек «друг на друга», причем взять можно только «верхний» элемент, т.е. тот, который был положен в стек последним. Для стека характерны операции, реализованные в следующих методах класса Stack:</span></p><p class="c1"><span class="c0">push(Object item) — помещает элемент на вершину стека;</span></p><p class="c1"><span class="c0">pop() — извлекает из стека верхний элемент;</span></p><p class="c1"><span class="c0">peek() — возвращает верхний элемент, не извлекая его из стека;</span></p><p class="c1"><span class="c0">empty() — проверяет, не пуст ли стек;</span></p><p class="c1"><span class="c0">search(Object item) — ищет «глубину» объекта в стеке. Верхний элемент имеет позицию 1, находящийся под ним — 2 и т.д. Если объекта в стеке нет, возвращает -1.</span></p><p class="c1"><span class="c0">Класс Stack является наследником класса Vector, поэтому имеет все его методы (и, разумеется, реализует интерфейсList). Однако если в программе нужно моделировать именно стек, рекомендуется использовать только пять вышеперечисленных методов</span><span class="c13">*</span><span class="c0">.</span></p><h3 class="c10"><a name="h.z6eid4vi5czm"></a><span class="c4">Паттерн проектирования Iterator</span></h3><p class="c1"><span class="c0">Преимущество использования массивов и коллекций заключается не только в том, что можно поместить в них произвольное количество объектов и извлекать их при необходимости, но и в том, что все эти объекты можно комплексно обрабатывать. Например, вывести на экран все шашки, содержащиеся в списке checkers. В случае массива мы пользуемся циклом for:</span></p><p class="c8"><span class="c9 c0">for</span><span class="c0">&nbsp;(</span><span class="c9 c0">int</span><span class="c0">&nbsp;i = 1; i &lt; array.length; i++){</span><span class="c0 c2">// обрабатываем элемент array[i]</span><span class="c0">}</span></p><p class="c1"><span class="c0">Имея дело со списком, мы можем поступить аналогичным образом, только вместо array[i] писать array.get(i). Но мы не можем поступить так с коллекциями, элементы которых не индексируются (например, очередью или множеством). А в случае индексированной коллекции надо хорошо знать особенности ее работы: как определить количество элементов, как обратиться к элементу по индексу, может ли коллекция быть разреженной (т.е. могут ли существовать индексы, с которыми не связано никаких элементов) и т.д.</span></p><p class="c1"><span class="c0">В программировании существует несколько испытанных временем и детально проработанных приемов структурной организации программы, называемых </span><span class="c0 c5">паттернами (шаблонами) проектирования</span><span class="c0">. Один из таких паттернов называется</span><span class="c0 c5">Iterator</span><span class="c0">. Идея заключается в том, что к коллекции «привязывается» объект, единственное назначение которого — выдать все элементы этой коллекции в некотором порядке, не раскрывая ее внутреннюю структуру.</span></p><p class="c1"><span class="c0">В пакете java.util описан интерфейс Iterator, воплощающий этот паттерн проектирования. Он имеет всего три метода:</span></p><p class="c1"><span class="c0">next() возвращает очередной элемент коллекции, к которой «привязан» итератор (и делает его текущим). Порядок перебора определяет сам итератор.</span></p><p class="c1"><span class="c0">hasNext() возвращает </span><span class="c6 c0">true</span><span class="c0">, если перебор элементов еще не закончен</span></p><p class="c1"><span class="c0">remove() удаляет текущий элемент</span></p><p class="c1"><span class="c0">Интерфейс Collection помимо рассмотренных ранее методов, имеет метод iterator(), который возвращает итератор для данной коллекции, готовый к ее обходу. С помощью такого итератора можно обработать все элементы любой коллекции следующим простым способом:</span></p><p class="c7"><span class="c0">Iterator iter = coll.iterator(); </span><span class="c0 c2">// coll — коллекция, элементы которой мы хотим обработать</span><span class="c9 c0">while</span><span class="c0">&nbsp;(iter.hasNext()) {</span><span class="c0 c2">// обрабатываем объект, возвращаемый методом iter.next()</span><span class="c0">}</span></p><p class="c1"><span class="c0">Для коллекций, элементы которых проиндексированы, определен более функциональный итератор, позволяющий двигаться как в прямом, так и в обратном направлении, а также добавлять в коллекцию элементы. Такой итератор имеет интрефейс ListIterator, унаследованный от интерфейса Iterator и дополняющий его следующими методами:</span></p><p class="c1"><span class="c0">previous() — возвращает предыдущий элемент (и делает его текущим);</span></p><p class="c1"><span class="c0">hasPrevious() — возвращает </span><span class="c6 c0">true</span><span class="c0">, если предыдущий элемент существует (т.е. текущий элемент не является первым элементом для данного итератора);</span></p><p class="c1"><span class="c0">add(Object item) — добавляет новый элемент перед текущим элементом;</span></p><p class="c1"><span class="c0">set(Object item) — заменяет текущий элемент;</span></p><p class="c1"><span class="c0">nextIndex() и previousIndex() — служат для получения индексов следующего и предыдущего элементов соответственно.</span></p><p class="c1"><span class="c0">В интерфейсе List определен метод listIterator(), возвращающий итератор ListIterator для обхода данного списка.</span></p><h3 class="c10"><a name="h.k0xejiypqfd0"></a><span class="c4">Класс LinkedList</span></h3><p class="c1"><span class="c0">LinkedList — двунаправленный список, реализующий интерфейсы List и Queue.</span></p><h3 class="c10"><a name="h.rldm748ft1fb"></a><span class="c4">Классы-множества</span></h3><p class="c1"><span class="c0">Класс HashSet реализует интерфейс Set. Он применяется в тех случаях, когда надо хранить только одну копию каждого элемента. Одинаковые объекты «вычисляются» с помощью метода hashCode() класса Object, который должен возвращать разные значения для разных объектов.</span></p><p class="c1"><span class="c14 c5">об упорядоченных множествах (интерфесах SortedSet и Comparator)</span></p><p class="c1"><span class="c0">Класс LinkedHashSet — множество, элементы которого хранятся в виде двунаправленного списка. Его наследник, классTreeSet является упорядоченным множеством, которое хранится в виде бинарного дерева, что обеспечивает быстроту поиска нужного элемента. TreeSet реализует интерфейс SortedSet.</span></p><p class="c3"><span></span></p></body></html>